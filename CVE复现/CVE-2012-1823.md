---
title: CVE-2012-1823
date: 2020-09-13 11:15:07
tags : [CTF,CVE]
categories: [CTF,CVE]
---

# <转载>PHP-CGI远程代码执行漏洞

## 原理

影响的:php < 5.3.12 or php < 5.4.2

转载链接：

- https://baijiahao.baidu.com/s?id=1637483210158521104&wfr=spider&for=pc1
- [Fastcgi协议分析 && PHP-FPM未授权访问漏洞 && Exp编写](https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html)

## 漏洞解读

### CGi 协议

CGI是一种网页表单和程序之间通信的一种协议，和HTTP协议一样，用于进行数据交换。可以用任何语言来写一个CGI脚本，这些语言只要能接受输入输出信息，读取环境变量。

php-cgi也是一个sapi。在远古的时候，web应用的运行方式很简单，web容器接收到http数据包后，拿到用户请求的文件（cgi脚本），并fork出一个子进程（解释器）去执行这个文件，然后拿到执行结果，直接返回给用户，同时这个解释器子进程也就结束了。基于bash、perl等语言的web应用多半都是以这种方式来执行，这种执行方式一般就被称为cgi

 <!--more-->

CGI把用户传递过来的数据穿过来的数据转变成key-value的字典。这个字典中不光有用户的数据，还有HTTP协议的参数，方便任何符合CGI协议的程序调用！但是本身不负责通信，通信的话是通过socket，也就是server。**cgi协议用来确定webserver（例如nginx），也就是内容分发服务器传递过来什么数据，什么样格式的数据**

![2fdda3cc7cd98d1021b8843eb2ceb20b7aec9043.jpeg](https://i.loli.net/2020/09/13/ifkl61EM342rQ8t.jpg)

每次启动时，需要经历加载php.ini文件->初始化执行环境->处理请求->返回内容给webserver->php-cgi进程退出的流程。

![f636afc379310a55337a36e524b449ac832610bf.jpeg](https://i.loli.net/2020/09/13/6H5KUrPxEvW2aAd.jpg)

这是PHP-fastcgi的原理图，本身上是对cgi的一次升级。fastcgi协议是对cgi协议效率提升的补充，主要是针对每次请求过来时都需要启动一个cgi解释器进程的优化，不再需要cgi解释器进程每次收到webserver请求后都需要重新加载php.ini文件和初始化执行环境。

HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下：

```
typedef struct {
  /* Header */
  unsigned char version; // 版本
  unsigned char type; // 本次record的类型
  unsigned char requestIdB1; // 本次record对应的请求id
  unsigned char requestIdB0;
  unsigned char contentLengthB1; // body体的大小
  unsigned char contentLengthB0;
  unsigned char paddingLength; // 额外块大小
  unsigned char reserved; 

  /* Body */
  unsigned char contentData[contentLength];
  unsigned char paddingData[paddingLength];
} FCGI_Record;
```

头由8个uchar类型的变量组成，每个变量1字节。其中，`requestId`占两个字节，一个唯一的标志id，以避免多个请求之间的影响；`contentLength`占两个字节，表示body的大小。

语言端解析了fastcgi头以后，拿到`contentLength`，然后再在TCP流里读取大小等于`contentLength`的数据，这就是body体。

Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。不需要该Padding的时候，将其长度设置为0即可。

可见，一个fastcgi record结构最大支持的body大小是`2^16`，也就是65536字节。

下面用一张图来解析一下type这个属性

![](https://i.loli.net/2020/09/13/CyqHuxPzhwRSQKT.jpg)

服务器中间件和后端语言通信，第一个数据包就是`type`为1的record，后续互相交流，发送`type`为4、5、6、7的record，结束时发送`type`为2、3的record。

当后端语言接收到一个`type`为4的record后，就会把这个record的body按照对应的结构解析成key-value对，这就是环境变量。环境变量的结构如下：

```
typedef struct {
  unsigned char nameLengthB0;  /* nameLengthB0  >> 7 == 0 */
  unsigned char valueLengthB0; /* valueLengthB0 >> 7 == 0 */
  unsigned char nameData[nameLength];
  unsigned char valueData[valueLength];
} FCGI_NameValuePair11;

typedef struct {
  unsigned char nameLengthB0;  /* nameLengthB0  >> 7 == 0 */
  unsigned char valueLengthB3; /* valueLengthB3 >> 7 == 1 */
  unsigned char valueLengthB2;
  unsigned char valueLengthB1;
  unsigned char valueLengthB0;
  unsigned char nameData[nameLength];
  unsigned char valueData[valueLength
          ((B3 & 0x7f) << 24) + (B2 << 16) + (B1 << 8) + B0];
} FCGI_NameValuePair14;

typedef struct {
  unsigned char nameLengthB3;  /* nameLengthB3  >> 7 == 1 */
  unsigned char nameLengthB2;
  unsigned char nameLengthB1;
  unsigned char nameLengthB0;
  unsigned char valueLengthB0; /* valueLengthB0 >> 7 == 0 */
  unsigned char nameData[nameLength
          ((B3 & 0x7f) << 24) + (B2 << 16) + (B1 << 8) + B0];
  unsigned char valueData[valueLength];
} FCGI_NameValuePair41;

typedef struct {
  unsigned char nameLengthB3;  /* nameLengthB3  >> 7 == 1 */
  unsigned char nameLengthB2;
  unsigned char nameLengthB1;
  unsigned char nameLengthB0;
  unsigned char valueLengthB3; /* valueLengthB3 >> 7 == 1 */
  unsigned char valueLengthB2;
  unsigned char valueLengthB1;
  unsigned char valueLengthB0;
  unsigned char nameData[nameLength
          ((B3 & 0x7f) << 24) + (B2 << 16) + (B1 << 8) + B0];
  unsigned char valueData[valueLength
          ((B3 & 0x7f) << 24) + (B2 << 16) + (B1 << 8) + B0];
} FCGI_NameValuePair44;
```

这其实是4个结构，至于用哪个结构，有如下规则：

1. key、value均小于128字节，用`FCGI_NameValuePair11`
2. key大于128字节，value小于128字节，用`FCGI_NameValuePair41`
3. key小于128字节，value大于128字节，用`FCGI_NameValuePair14`
4. key、value均大于128字节，用`FCGI_NameValuePair44`

为什么我只介绍`type`为4的record？因为环境变量在后面PHP-FPM里有重要作用，之后写代码也会写到这个结构。`type`的其他情况，请自行百度。

## PHP-FPM

上面说到这个协议会将用户上传到数据解析成key-value的键值对的情况，但是打包好后传给谁呢？那个人就是PHP-FPM。

举个例子，用户访问`http://192.168.0.0.1/index.php?ace=1&cve=2`，如果web目录是`/var/www/html`，那么Nginx会将这个请求变成如下key-value对：

```
{
    'GATEWAY_INTERFACE': 'FastCGI/1.0',
    'REQUEST_METHOD': 'GET',
    'SCRIPT_FILENAME': '/var/www/html/index.php',
    'SCRIPT_NAME': '/index.php',
    'QUERY_STRING': '?a=1&b=2',
    'REQUEST_URI': '/index.php?ace=1&cve=2',
    'DOCUMENT_ROOT': '/var/www/html',
    'SERVER_SOFTWARE': 'php/fcgiclient',
    'REMOTE_ADDR': '127.0.0.1',
    'REMOTE_PORT': '12345',
    'SERVER_ADDR': '127.0.0.1',
    'SERVER_PORT': '80',
    'SERVER_NAME': "localhost",
    'SERVER_PROTOCOL': 'HTTP/1.1'
}
```

这个数组其实就是PHP中`$_SERVER`数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充`$_SERVER`数组，也是告诉fpm：“我要执行哪个PHP文件”。然后FPM拿到这些环境变量之后就是进行执行，去找那个PHP文件。

## 漏洞解析

这个漏洞简单的来说就是用户提供的**未加=**的数据被当作PHP-CGI的参数，最后导致了一系列的结果。这个是RFC3875中规定的，Apache服务器按要求实现了这个功能，但PHP并没有注意到RFC的这一个规则，也许是曾经注意并处理了，处理方法就是web上下文中不允许传入参数。

但是开发者是为了方便使用类似`#!/usr/local/bin/php-cgi -d include_path=/path`的写法来进行测试，认为不应该限制php-cgi接受命令行参数，而且这个功能不和其他代码有任何冲突。于是就把限制给删掉了，但是很显然，根据RFC中对于命令行的说明，参数不光能够通过上诉方法传入，还可以通过请求参数。

## 漏洞利用

 - `-c` 指定php.ini文件的位置
 - `-n` 不要加载php.ini文件
 - `-d` 指定配置项
 - `-b` 启动fastcgi进程
 - `-s` 显示文件源码
 - `-T` 执行指定次该文件
 - `-h`和`-?` 显示帮助

这次放在源代码之后就可以进行利用，简单方便。当然继续看下去， 看见**-d**这个牛鼻的参数这个漏洞又怎么会这么简单呢？？

实际使用中

```
allow_url_include:远程文件包含
`auto_prepend_file`：包含我们的代码
```

我们继续解析:

## 任意代码执行

这里怎么去任意代码执行，首先有以下几个问题:

- 即使我们能控制`SCRIPT_FILENAME`，让fpm执行任意文件，也只是执行目标服务器上的文件，并不能执行我们需要其执行的文件。

- 我们怎么把代码上传上去

  PHP语言的特性就是有很多很强大的配置项`auto_prepend_file`和`auto_append_file`。

  ```
  1.auto_prepend_file是告诉PHP，在执行目标文件之前，先包含auto_prepend_file中指定的文件；
  2.auto_append_file是告诉PHP，在执行完成目标文件后，包含auto_append_file指向的文件。
  ```

  如果我们把auto_prepend__file设置成`php://input`然后我们再执行任何的php文件前都会包含一些post的内容了，所以我们只要post一下，这些代码就都能够被执行了，（当然，还需要开启远程文件包含选项`allow_url_include`）

这个时候就有下一个问题了，就是我们怎么设置这个环境变量的值呢？

```
PHP_VALUE`和`PHP_ADMIN_VALUE
这两个环境变量就是用来设置PHP配置项的，PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项。（disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中
```

这就是他们两个的特长了。

所以，我们最后传入如下环境变量：（直接和FPM进行通信）

```
{
    'GATEWAY_INTERFACE': 'FastCGI/1.0',
    'REQUEST_METHOD': 'GET',
    'SCRIPT_FILENAME': '/var/www/html/index.php',
    'SCRIPT_NAME': '/index.php',
    'QUERY_STRING': '?a=1&b=2',
    'REQUEST_URI': '/index.php?a=1&b=2',
    'DOCUMENT_ROOT': '/var/www/html',
    'SERVER_SOFTWARE': 'php/fcgiclient',
    'REMOTE_ADDR': '127.0.0.1',
    'REMOTE_PORT': '12345',
    'SERVER_ADDR': '127.0.0.1',
    'SERVER_PORT': '80',
    'SERVER_NAME': "localhost",
    'SERVER_PROTOCOL': 'HTTP/1.1'
    'PHP_VALUE': 'auto_prepend_file = php://input',
    'PHP_ADMIN_VALUE': 'allow_url_include = On'
}
```

## Nginx（IIS7）解析漏洞（文件上传)

Nginx和IIS7曾经出现过一个PHP相关的解析漏洞（测试环境`https://github.com/phith0n/vulhub/tree/master/nginx_parsing_vulnerability`），该漏洞现象是，在用户访问`http://127.0.0.1/favicon.ico/.php`时，访问到的文件是favicon.ico，但却按照.php后缀解析了。

用户请求`http://127.0.0.1/favicon.ico/.php`，nginx将会发送如下环境变量到fpm里：

```
{
    ...
    'SCRIPT_FILENAME': '/var/www/html/favicon.ico/.php',
    'SCRIPT_NAME': '/favicon.ico/.php',
    'REQUEST_URI': '/favicon.ico/.php',
    'DOCUMENT_ROOT': '/var/www/html',
    ...
}
```

正常来说，`SCRIPT_FILENAME`的值是一个不存在的文件`/var/www/html/favicon.ico/.php`，是PHP设置中的一个选项`fix_pathinfo`导致了这个漏洞。PHP为了支持Path Info模式而创造了`fix_pathinfo`，在这个选项被打开的情况下，fpm会判断`SCRIPT_FILENAME`是否存在，如果不存在则去掉最后一个`/`及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。

所以，第一次fpm发现`/var/www/html/favicon.ico/.php`不存在，则去掉`/.php`，再判断`/var/www/html/favicon.ico`是否存在。显然这个文件是存在的，于是被作为PHP文件执行，导致解析漏洞。

正确的解决方法有两种，一是在Nginx端使用`fastcgi_split_path_info`将path info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的`security.limit_extensions`配置项，避免其他后缀文件被解析

## `security.limit_extensions`配置

写到这里，PHP-FPM未授权访问漏洞也就呼之欲出了。PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。

此时，`SCRIPT_FILENAME`的值就格外重要了。因为fpm是根据这个值来执行php文件的，如果这个文件不存在，fpm会直接返回404：

[![14931285844835.jpg](https://www.leavesongs.com/media/attachment/2017/04/25/703367c4-af98-4702-85f0-794b30776a4f.073e567856db.jpg)](https://www.leavesongs.com/media/attachment/2017/04/25/703367c4-af98-4702-85f0-794b30776a4f.jpg)

在fpm某个版本之前，我们可以将`SCRIPT_FILENAME`的值指定为任意后缀文件，比如`/etc/passwd`；但后来，fpm的默认配置中增加了一个选项`security.limit_extensions`：

```
; Limits the extensions of the main script FPM will allow to parse. This can
; prevent configuration mistakes on the web server side. You should only limit
; FPM to .php extensions to prevent malicious users to use other extensions to
; exectute php code.
; Note: set an empty value to allow all extensions.
; Default Value: .php
;security.limit_extensions = .php .php3 .php4 .php5 .php7
```

其限定了只有某些后缀的文件允许被fpm执行，默认是`.php`。所以，当我们再传入`/etc/passwd`的时候，将会返回`Access denied.`：

[![14931290357686.jpg](https://www.leavesongs.com/media/attachment/2017/04/25/99d10f40-7dc3-46f3-a0bb-dae71e9d550b.30fa707133a3.jpg)](https://www.leavesongs.com/media/attachment/2017/04/25/99d10f40-7dc3-46f3-a0bb-dae71e9d550b.jpg)

> ps. 这个配置也会影响Nginx解析漏洞，我觉得应该是因为Nginx当时那个解析漏洞，促成PHP-FPM增加了这个安全选项。另外，也有少部分发行版安装中`security.limit_extensions`默认为空，此时就没有任何限制了。

由于这个配置项的限制，如果想利用PHP-FPM的未授权访问漏洞，首先就得找到一个已存在的PHP文件。

万幸的是，通常使用源安装php的时候，服务器上都会附带一些php后缀的文件，我们使用`find / -name "*.php"`来全局搜索一下默认环境：

[![14931297810961.jpg](https://www.leavesongs.com/media/attachment/2017/04/25/15695b8e-79ae-4f32-b061-cc5f52236e18.a5365d20818a.jpg)](https://www.leavesongs.com/media/attachment/2017/04/25/15695b8e-79ae-4f32-b061-cc5f52236e18.jpg)

找到了不少。这就给我们提供了一条思路，假设我们爆破不出来目标环境的web目录，我们可以找找默认源安装后可能存在的php文件，比如`/usr/local/lib/php/PEAR.php`。

exp:：https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75 

