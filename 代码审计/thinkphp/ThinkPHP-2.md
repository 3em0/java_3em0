---
title: ThinkPHP-2
date: 2020-09-18 08:07:33
tags: ['编程',ThinkPHP]
categories: 编程
toc: true
---

#  ThinkPhP学习第二天

## 聚合、原生、子查询

### 一、聚合查询

查询数量

```
$result = Db::name('user')->count('uid');
uid如果不加，就是全查询
```

最大/小值

```
$result = Db::name('user')->max/min('price'，可选参数);
取值为bool，可以判断整型还是浮点型
```

平均值和总和同SQL

<!--more-->

### 二、子查询

1.fetchSql（）可以不执行sql，而返回sql

```
$subQuery = Db::name('user')->fetchSql(true)->select()
```

2.bulidsql

```
$subQuery = Db::name('user')->buildSql(true);
自动加括号
```

3.拼装子查询

```
$subQuery = Db::name('two')->field('uid')->where('gender','男')->buildSql(true);
$result = Db::name('one')->where('id','exp','in'.$subQuery)->select();
return json($result);
```

in 查询需要使用exp拼接

4.闭包查询

```
$result = Db::name('one')->where('id', 'in', function ($query) { $query->name('two')->where('gender', '男')->field('uid'); })->select();
```

### 三、原生查询

1. 使用 query()方法，进行原生 SQL 查询，适用于读取操作，SQL 错误返回 false； Db::query('select * from tp_user');
2. 使用 execute 方法，进行原生 SQL 更新写入等，SQL 错误返回 false； Db::execute('update tp_user set username="孙悟空" where id=29');



## 链式查询方法

### 一、where

1.基础的where查询

2.索引数组查询

```
//$result = Db::name('user')->where([
//            'price' => 100,
//            'gender'=> '男'
//        ])->select();
//        $result = Db::name('user')->where([
//            'price' => [60,70,80],
//            'gender'=> '男'
//        ])->select();
$result = Db::name('user')->where([
['price','=',100],
['gender','=','男']
])->select();
```

3.复杂数组拆分

```
$map[] = ['gender', '=', '男']; 
$map[] = ['price', 'in', [60, 70, 80]];
$result = Db::name('user')->where($map)->select();
```

4.字符串形式传递

```
Db::name('user')->where('gender="男" AND price IN (60, 70, 80)')->select();
```

### 二、field

1.指定字段名

```
Db::name('user')->field('id, username, email')->select(); 
Db::name('user')->field(['id', 'username', 'email'])->select();
```

2.设置别名

```
Db::name('user')->field('id,username as name,email')->select()
```

3.可以直接在里面调用函数

```
Db::name('user')->field('id,username as name,email,sum(price)')->select()
```

4.true参数

```
 $result = Db::name('user')->field(true)->select();
 显式查询所有字段名
  $result = Db::name('user')->field('username',true)->select();
  不显示username字段
```

5.insert

```
Db::name('user')->field('username, email, details')->insert($data);
```

### 三、alias

1. 使用 alias()方法，给数据库起一个别名； `Db::name('user')->alias('a')->select();`

### 四、limit方法

1.实现输出限制

```
$result = Db::name('user')->limit(5)->select();
```

2.实现分页

```
$result = Db::name('user')->limit(5,5)->select();
```

第一个参数是起始的位置，第二个参数是长度

### 五、page方法实现自动分页

```
Db::name('user')->page(1, 5)->select(); 
//第二页 Db::name('user')->page(2, 5)->select();
```

###　六、order排序方法

```
1. 使用 order()方法，可以指定排序方式，没有指定第二参数，默认 asc； Db::name('user')->order('id', 'desc')->select();
2. 支持数组的方式，对多个字段进行排序； Db::name('user')->order(['create_time'=>'desc', 'price'=>'asc'])->select();
在同一创建的时间，再按照价格来排序
```

### 七、group方法

1. 使用 group()方法，给性别不同的人进行 price 字段的总和统计； Db::name('user')->field('gender, sum(price)')->group('gender')->select();
2. 也可以进行多字段分组统计； Db::name('user')->field('gender, sum(price)') ->group('gender,password')->select();

### 八、having方法

```
$result = Db::name('user') ->field('gender, sum(price)') ->group('gender') ->having('sum(price)>600') ->select();
```

## 模型的定义

模型的类名和控制器相同的名字相同时，可以直接采取别名`as`

如果类名和关键字的相同时，就可以开启`class_suffix`

```
class User extends Model//只要定义了就和数据库自动链接了
{
    //设置主键
    protected $pk = 'uid';
    //设置其他表
    protected $table = 'tp_one';
    //初始化
    protected static function init()
    {
        //parent::init(); // TODO: Change the autogenerated stub
        echo "初始化";
    }
}
```

```

namespace app\controller;
use \app\model\User as UserModel;//模型操作不需要指定表

class User
{
    public function index()
    {
        // UserModel.class.php
        // UserController.class.php
        $result = UserModel::select();
        //return json($result);
    }
}
```

数据库操作返回的列表时一个二维数组，模型返回的是一个结果集

## 模型添加与删除

### 一、增加

```php
 public function insert()
    {
        //$user = new \app\model\User();
        $user = new UserModel();
        //return $user;
//        $user->username = '李白';
//        $user->password = '123';
//        $user->gender = '男';
//        $user->email = 'libai@163.com';
//        $user->price = 100;
//        $user->details = '123';
//        $user->uid = 1011;
//        $user->create_time = date('Y-m-d H:i:s');
//        $insert = $user->save([ 'username' => '李白', 'password' => '123', 'gender' => '男', 'email' => 'libai@163.com', 'price' => 100, 'details' => '123', 'uid' => 1011, 'create_time' => date('Y-m-d H:i:s') ]);
//        return Db::getLastSql()
//        echo $insert;//bool值
//        $user->replace()->save();
//        $user->replace()->save();replace插入
        //批量新增
//        $dataAll = [ [ 'username' => '李白 1', 'password' => '123', 'gender' => '男', 'email' => 'libai@163.com', 'price' => 100, 'details' => '123', 'uid' => 1011, 'create_time' => date('Y-m-d H:i:s') ], [ 'username' => '李白 2', 'password' => '123', 'gender' => '男', 'email' => 'libai@163.com', 'price' => 100, 'details' => '123', 'uid' => 1011, 'create_time' => date('Y-m-d H:i:s') ] ];
//        $user = new UserModel();
//        print_r($user->saveAll($dataAll));

    }
```

### 二、删除

```
 $user = UserModel::get(245);
//        print_r($user->delete());
        //UserModel::destroy(244);
        //批量删除
        //UserModel::destroy([243,242]);
        //条件删除
        UserModel::where('id','>',122)->delete();
        //闭包删除
        UserModel::destroy(function ($query){
            $query->where('id','>',118);
        });
```

## 模型的修改和查询

###　模型修改和查询

```
 public function delete()
    {
//        $user = UserModel::get(245);
//        print_r($user->delete());
        //UserModel::destroy(244);
        //批量删除
        //UserModel::destroy([243,242]);
        //条件删除
        UserModel::where('id','>',122)->delete();
        //闭包删除
        UserModel::destroy(function ($query){
            $query->where('id','>',118);
        });
    }
    public function update()
    {
//        $user = UserModel::get(24);
//        $user->username = '小刚';
//        $user->save();
        //寻找的时候更加精确的进行
        //$user = UserModel::where('username','小刚')->find();
        //save 只能更新变化的数据
        //$user->force()->save();强制更新
//        $user = UserModel::get(24);
//        $user->username = '小刚';
//        $user->price = Db::raw('price+1');
//        $user->price = ['inc',1];
        //直接通过 save([],[])两个数组参数的方式更新数据； 第一个是数据，第二个是where
//        $user->save();
//        $user = new UserModel();
//        $user->saveAll([
//            ['id'=>118, 'username'=>'李白', 'email'=>'libai@163.com'], ['id'=>128, 'username'=>'李白', 'email'=>'libai@163.com'], ['id'=>129, 'username'=>'李白', 'email'=>'libai@163.com']
//        ]);第一条必须是主键，必须是ID
//        UserModel::where('id', 118)->update([ 'username' => '李黑', 'email' => 'lihei@163.com' ]);
//        UserModel::update([ 'id' => 118, 'username' => '李黑', 'email' => 'lihei@163.com' ]);
        //不用where的时候，第一条数据必须是主键
        //显示更新 $user->isUpdate(true)->save();
        //显示新增 $user->isUpdate(false)->save();
        //模型->符号，可以得到单独的字段数据
        //模型端 采用 return self::where('username', '辉夜')->find()->getAttr('username');
//        通过 all()方法，实现 IN 模式的多数据获取；
//        $user = UserModel::all('79, 118, 128');
//        $user = UserModel::all([79, 118, 128]);
//        模型支持动态查询：getBy*，*表示字段名；
        UserModel::getByUsername('辉夜');
        UserModel::getByEmail('huiye@163.com');

    }
```

## 模型获取器和修改器

获取器

```
//创建一个获取器
    public function getStatusAttr($value,$data)
    {
        $myGet = [-1=>'删除',0=>'禁用',1=>'正常',2=>'待审核'];
        return $myGet[$data['status']];
    }
    //创建一个虚拟字段的获取器，可以对多个字段进行过滤
    public function getNothingAttr($value,$data){
        return $data;
    }
```

动态获取器

```
$result = UserModel::WithAttr('status', function ($value) { $status = [-1=>'删除', 0=>'禁用', 1=>'正常', 2=>'待审核']; return $status[$value]; })->select();
        return json($result);
```

修改器（插入，修改，更新，的格式化）

```
//创建一个修改器
    public function setEmailAttr($value)
    {
        return strtoupper($value);
    }
```

```
//修改器的优先级高于获取器
```

## 模型搜索器和数据集

### 一、模型搜索器

```
//创建一个搜索器，邮箱模糊查询
    public function searchEmailAttr($query, $value,$data)
    {
        $query->where('email', 'like', $value . '%');
        if(isset($data)){
            $query->order($data['sort']);
        }

    }

    //创建一个搜索器，限定时间
    public function searchCreateTimeAttr($query, $value)
    {
        $query->whereBetweenTime('create_time', $value[0], $value[1]);
    }
```

调用

```
$result  = UserModel::withSearch(['email','create_time'=>'ctime'],[
            'email' => 'xiao',
            'ctime' => ['2014-1-1', '2019-1-1'],
            'sort' => ['price'=>'desc']
        ])->select();//第一个参数限定搜索器
```

### 二、数据集

**在select前面操作叫链式查询，在后面叫数据集操作**

```
$result = UserModel::select()->where('price','<',80)->order('id','asc');
        $result->hidden(['password']);隐藏
        $result->visible(['password']);
        $result->append(['nothing'])->withAttr('email',function ($value){
            return strtoupper($value);
            });不需要返回数据
      $result = $result->filter(function ($data){
           return $data['price'] < 80;
        });
        $result1 = UserModel::where('price','>',80)->select();
        $result2 = UserModel::where('price','<',80)->select();
        return json($result1->diff($result2));//需要返回数据//并
        return json($result1->intersect($result2));//差集
```

**filter()需要返回数据，但是withattr()是直接在内存中进行处理的**

## 模型自动时间戳和只读字段

全局开启

```
// 自动写入时间戳字段
    'auto_timestamp'  => false,
```

部分开启

```
  //时间戳自定义
    //protected $createTime = 'create_at';
     protected $updateTime = false;//关闭更改时间
//也可以动态实现不修改 update_time，具体如下： $user->isAutoWriteTimestamp(false)->save();
```

只读字段

```
//设置只读字段
    protected $readonly = ['username', 'email'];
动态设置
	$user->readonly(['username', 'email'])->save();
	只读字段只支持模型方式不支持数据库方式；
```

## 模型类型转换和数据完成

```
在模型端设置你想要类型转换的字段属性，属性值为数组；
protected $type = [ 
'price' => 'integer',
'status' => 'boolean', 
'create_time' => 'datetime:Y-m-d' ];

```

**类型转换还是会调用属性里的获取器等操作，编码时要注意这方面的问题**

```
protected $auto = ['email'];
protected $insert = ['uid'=>1];
protected $update = [];
auto 表示新增和修改操作，insert 只表示新增，update 只表示修改
 auto 表示新增和修改均要自动完成，而不给默认值的字段需要修改器提供； 
```

修改时，如果你不去修改邮箱，在数据自动完成强制完成，会自动完成大写； 8. 也就是说，邮箱的大写，设置 update 更加合适，因为新增必填必然触发修改器； 9. 对于 update 自动完成，和 auto、insert 雷同，自行演示；